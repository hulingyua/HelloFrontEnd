# Node.js

### 1. 浏览器的组成

- **用户界面 ( User Interface )**
  - 地址栏、前进/后退、书签菜单等
- **渲染引擎 ( Rendering engine )**
  - 负责显示请求的内容
- **浏览器引擎 ( Browser engine )**
  - 在用户界面和渲染引擎之间传达指令 ( 如刷新 )
- **网络模块 ( Networking )**
  - 用户网络调用
- **UI 后端 ( UI Backend )**
  - 用户绘制基本的窗口小部件 ( 如对话框、弹窗等 )
- **JS 解释器 ( JavaScript Interpreter )**
  - 用来解析和执行 JS 代码 ( 如 Chrome 的 V8 引擎 )
- **数据存储 ( Data Persistence )**
  - 属于持久层 ( Cookie、LocalStorage、SessionStorage )

### 2. 浏览器渲染引擎工作原理

##### 2.1 渲染引擎 ( 排版引擎、浏览器内核 ), 其作用是用来渲染显示页面

##### 2.2 主流的渲染引擎

- **Chrome浏览器**: Blink 引擎 ( WebKit 引擎的一个分支 )
- **Safari浏览器**: WebKit 引擎
- **FireFox浏览器**: Gecko 引擎
- **Opera浏览器**: Blink 引擎 ( 早期使用 Presto 引擎 )
- **Internet Explorer 浏览器**: Trident 引擎
- **Edge 浏览器**: EdgeHTML 引擎 ( Trident的一个分支 )

##### 2.3 渲染引擎的工作原理

1. **解析 HTML 构建 DOM 树**。DOM 是W3C组织推荐的处理可扩展置标语言的标准编程接口。
2. **构建渲染树**。渲染树并不等同于 DOM 树, 因为像 head 标签或 display : none 这样不需要渲染的元素, 就没有必要放到渲染树中了, 但是它们在Dom树中。
3. **对渲染树进行布局**。定位坐标和大小、确定是否换行、确定position、overflow、z-index等, 这个过程叫 `layout` 或 `reflow`。
4. **绘制渲染树**。调用操作系统底层 API, 进行绘制操作。

### 3. Node是什么

node 是一个开发平台, 就像 Java 开发平台、.Net 开发平台、PHP 开发平台一样, 有自己对应的编程语言 ( javascript )、有语言运行时 ( V8引擎 )、有能实现特定功能的 API ( fs、http 等 )。基于 Node.js 可以开发控制台程序 ( 命令行程序 )、桌面应用程序 ( GUI -- 借助 node-webkit、electron 等框架实现 )、Web 应用程序 ( 网站 )

### 4. Node 有哪些特点

1. 事件驱动 ( 事件触发, 会执行回调函数里的代码 )
2. 非阻塞 I/O
3. 单线程
4. 拥有世界最大的开源生态系统 NPM

### 5. REPL

Read-Eval-Print-Loop ( **交互式解释器** )

浏览器进入 REPL 环境: 控制台, 命令行进入 REPL 环境:  输入 `node` 命令即可进入。退出: `.exit` 或 `ctrl + c`

- R 读取 - 读取用户输入, 解析输入了 Javascript 数据结构并存储在内存中
- E 执行 - 执行输入的数据结构
- P 打印 - 输出结果
- L 循环 - 循环操作以上步骤

### 6. 规范

1. 文件命名规范

  - 不要使用中文命名
  - 不要使用空格
  - 不要使用Node关键字
  - 建议以 ‘-’ 分割单词 ( my-demo.js )

2. 编写代码规范

  - 命名: 变量名和函数名遵循驼峰命名法
  - 引入: 变量名最好和模块名一样
  - 引号: 一般使用单引号, **嵌套时内部使用双引号**, json 数据使用双引号, **动态字符串使用反引号**

### 7. 文件系统

##### 7.1 写入文件

```javascript
`fs.writeFile(file, data[, options], callback)`
var fs = require('fs');
var msg = '但愿人长久，千里共婵娟。';
fs.writeFile('./data.txt', msg, function(err){
  if(err){
    throw err;
  }
  console.log('写入成功');
});
console.log('异步操作');
// 执行结果: 先输出`异步操作`, 再输出`写入成功`
```

##### 7.2 读取文件

```javascript
`fs.readFile(path[, options], callback)`
`path 相对的是 Node 执行命令所在的路径`
var fs = require('fs');
fs.readFile('./data.txt','utf8',function(err,data){
  // if(err) throw err;
`ENOENT: Error No Entity`
  // { Error: ENOENT: no such file or directory
  // errno: -4058,
  // code: 'ENOENT',
  // syscall: 'open'}
  if(err){
    throw err;
    `异步不能使用try...catch...`
  }
  // console.log(data);
  // <Buffer 64 6f 6e 27 74 20 6c 65 74 20 6d 65 20 67 6f 2e>
  // Buffer是一个缓冲二进制数据, 2位的16进制字节数组,负责传输文件
  
  // 转化为字符串方法1: toString(['utf8'])
  // 转化为字符串方法2: 设置第二个参数,编码格式为'utf8'/'utf-8'
  console.log(data.toString());
});
```

##### 7.3 同步读取文件

```javascript
`fs.readFileSync(path[, options])`
var fs = require('fs');
`同步使用try...catch...捕获异常`
try{
  var data = fs.readFileSync('./data1.txt','utf8');
  console.log(data);
}catch(err){
  console.log(`ERROR=>${err}`);
  // ERROR=>Error: ENOENT: no such file or directory
}
```

### 8. __dirname

```javascript
// 当前 js 文件所在的`文件夹`目录
console.log(__dirname); // E:\Program Files\wamp\www\node
// 应用：path 使用绝对路径
var fs = require('fs');
var path = require('path');
fs.readFile(path.join(__dirname,'./data.txt'),'utf8',function(err,data){
  console.log(data);
});
```

### 9. HTTP服务

```javascript
// 一、极简
var http = require('http'); // 1. 加载 http 模块
var server = http.createServer(); // 2. 创建 http 服务
server.on('request',function(req, res){
  console.log('3. 为 http 服务对象添加 request 事件处理程序');
  `浏览器可能显示乱码解决方案`
  res.setHeader('content-type','text/plain;charset=utf-8');
  res.write('Hello world!');
  res.end();
});
// 4. 开启 http 服务监听, 准备接收客户端请求
server.listen(8080,function(){
  console.log('App listening at http://localhost:8080');
});

// 二、一体化
var http = require('http');
http.createServer(function(req, res){
  res.setHeader('content-type','text/plain;charset=utf-8');
  `text/plain 告诉浏览器以纯文本的格式进行解析内容`
  `text/html 告诉浏览器发送的数据是 html 类型`
  `charset=utf-8 告诉浏览器以 utf-8 编码格式解析文字`
  res.end('<h1>一级标题</h1>');
}).listen(8080,function(){
  console.log('App listening at http://localhost:8080');
});
```

### 10. 根据不同的URL请求响应不同的纯文本

```javascript
var http = require('http');
http.createServer(function(req,res){
  console.log(req.url);
  res.setHeader('content-type','text/plain;charset=utf-8');
  if(req.url === '/' || req.url === '/index'){
    res.end('这是首页');
  }else if(req.url === '/login'){
    res.end('这是登录页');
  }else if(req.url === '/register'){
    res.end('这是注册页');
  }else{
    res.end('404 NO FOUND');        
  }
}).listen(8080,function(){
  console.log('App listening at http://localhost:8080');
});
```

### 11. request 对象
服务器解析用户提交的 http 请求报文，将结果解析到 request 对象中。凡是要获取和用户请求相关的数据都可以通过 request 对象获取。request 对象类型 `http.IncomingMessage` , 继承自stream.Readable。

```javascript
`request.headers` — 请求头 (对象)
`request.rawHeaders` — 请求头 (数组)
`request.httpVersion` — http 版本
`request.method` — 请求方式
`request.url` — 请求 url 路径
```

### 12. response 对象

在服务器端用来向用户做出响应的对象。凡是需要向用户（客户端）响应的操作，都需要通过 response 对象来进行。response 对象类型 `http.ServerResponse`

```javascript
// chunk: 要写入的数据,可以是字符串 或者 二进制数据 ( 必填 ) <string> | <Buffer>
`response.write(chunk[, encoding[, callback])` — 写入数据
`response.end([data][, encoding][, callback])` — 结束响应
`response.setHeader(name, value)` — 设置响应报文头
`response.statusCode` — 设置或者读取 http 状态码
`response.statusMessage` — 设置或读取 http 响应状态消息
`response.writeHead(statusCode [, statusMessage][, headers])` — 设置响应头信息
// e.g
res.statusCode = 200;
res.statusMessage = 'OK';
res.setHeader('content-type','text/plain;charset=utf-8');
// 设置响应报文头(等同于上面)
res.writeHead(200,'OK',{
  'content-type':'text/plain;charset=utf-8'
});
// 写入数据, 返回给浏览器
res.write('Hello World');
// 结束响应
res.end('DONE');
```

  [MDN-HTTP response status codes](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status)

### 13. 模板引擎 [underscore](http://underscorejs.org/#template)

```javascript
var _ = require('underscore');
//1. 模板字符串
var oldHtml = '<h1><%= name %></h1>';
//2. 生成模板函数
// 参数: 模板字符串
// 返回值: 模板函数
var template = _.template(oldHtml);
//3. 传值
var newHtml = template({ name : 'Mike' });
```

### 14. Node.js 模块

在 Node.js 开发中, 每一个文件就可以认为是一个模块

##### 14.1 核心模块 ( Core Module ) 也称内置模块、原生模块

- fs——读写文件
- http——创建服务并监听服务
- path——拼接路径
- url——解析 req.url , 把 query 的查询字符串转化为对象 ( /add?id=123&name='mike' )
- querystring——解析查询字符串 ( id=123&name='mike' )

##### 14.2 文件模块

根据文件路径引入的模块, 如果加载时, 没有指定后缀名, 那么就按照如下顺序加载响应模块

1. .js
2. .json
3. .node ( C/C++ 编写的模块 )

##### 14.3 自定义模块 ( 第三方模块 )

需要额外通过 npm 安装的模块

- mime: 根据路径/文件后缀名, 获取对应的文件类型 ( mime.getType() )
- underscore: 模板引擎 , 给 html 文件赋值

##### 14.4 require 加载模块的顺序

看 require() 加载模块时传入的参数是否以 `./ 或 ../ 或 /` 等等这样的方式开头(相对路径和绝对路径都可以)
- 如果是, 则说明是**文件模块**, 那么会按照传入的路径直接去查询对应的模块
  - 如果是具体的文件名 `require('./test.js')` , 则直接根据给定的路径去加载模块, 找到了就加载成功, 否则加载失败
  - 不是具体的文件名 `require('./test')` , 首先会根据指定的路径, 依次添加文件后缀 .js、.json、.node 进行匹配, 如果找不到匹配, 则会认为 test 是文件夹, 并查找是否有 test 目录 (尝试找 test 包), 找不到就加载失败; 如果找到了, 依次在 test 目录下查找 package.json 文件 (找到该文件后尝试找 main 字段中的入口文件) 、index.js、index.json、index.node, 找不到则加载失败。
- 如果不是, 就认为传入的是**模块名称 ( 如: require('http')、require('mime') )

### Express

基于 Node.js 平台，快速、开放、极简的 web 开发框架。

```bash
$ npm install express --save
```

#####★ req.query

```javascript
// 该方法用于获取 get 方式请求的字符串对象
// get 请求的 url 路径: add?title=baidu&url=www.baidu.com&text=百度一下，你就知道
req.query; // {title : baidu, url : www.baidu.com, text : 百度一下，你就知道}
```

##### ★ req.body

```javascript
// 该方法用于获取 post 方式请求的字符串对象
`必须使用第三方模块 body-parser`
// 安装: npm i body-parser -S
var bodyParser = require('body-parser');
`一定要在正式处理请求之前设置 body-parser`
// Contains key-value pairs of data submitted in the request body. By default,
// it is undefined, and is populated when you use body-parsing middleware such as body-parser and multer.
// urlencoded: 把 post 请求的数据, 转化为对象
// extended: 以前使用第三方模块(qs 需额外安装), 值为 true , 在新版本中可以将值设为 false 以使用内置模块 querystring
app.use(bodyParser.urlencoded({extended:false}));
// 之后就可以直接使用了
req.body; // {title : baidu, url : www.baidu.com, text : 百度一下，你就知道}
```

### Async

Async是一个实用程序模块, 它为异步 JavaScript 提供了强大的功能。

[GitHub](https://github.com/caolan/async) 、 [官网](https://caolan.github.io/async/)

##### ★ series

| Name     | Type    | Description                              |
| -------- | ------- | ---------------------------------------- |
| tasks    | 数组 或 对象 | 包含异步函数的集合可以串行运行。 每个函数都可以用任意数量的可选结果值来完成。  |
| callback | 函数      | 一个可选的回调，一旦**所有的串行任务完成时运行**。 该函数获得一个结果数组（或对象），其中包含传递给回调的所有结果参数。 用 ( err, result ) 调用。 |

Example

  ```javascript
`series(tasks, callback)`
// 运行任务集合中的函数, 每个函数必须等待前一个函数运行完成。如果集合中的任何一个函数出现异常并将错误传递给其回调函数, 此时将不会运行之后的函数, 并立即使用错误值调用回调函数。否则, 回调函数会在任务结束时收到一个结果数组。也可以使用对象而不是数组, 每个属性将作为一个函数运行, 结果将作为一个对象而不是一个数组传递给最终的回调。
async.series([
    function(callback) {
        callback(null, 'one');
    },
    function(callback) {
        callback(null, 'two');
    }
],
// optional callback
function(err, results) {
    // results is now equal to ['one', 'two']
});

async.series({
    one: function(callback) {
        setTimeout(function() {
            callback(null, 1);
        }, 200);
    },
    two: function(callback){
        setTimeout(function() {
            callback(null, 2);
        }, 100);
    }
}, function(err, results) {
    // results is now equal to: {one: 1, two: 2}
});
  ```

##### ★ parallel

| Name     | Type    | Description                              |
| -------- | ------- | ---------------------------------------- |
| tasks    | 数组 或 对象 | 要运行的异步函数的集合。 每个异步函数都可以使用任意数量的可选结果值来完成。   |
| callback | 函数      | 一个可选的回调函数，一旦**所有的并行任务完成时运行**。 该函数获得一个结果数组（或对象），其中包含传递给回调的所有结果参数。 用 ( err, result ) 调用。 |

Example

  ```javascript
`parallel(tasks, callback)`
// 并行运行任务集合，而不必等待前一个函数完成。 如果任何函数将错误传递给它的回调函数，主回调函数会立即调用错误的值。 一旦任务完成，结果作为一个数组传递给最终的回调。
// 并行是关于并行启动I / O任务，而不是并行执行代码。 如果你的任务不使用任何定时器或者执行任何I / O，他们将会实际上被串行执行。 每个任务的任何同步设置部分都会一个接一个地发生。 JavaScript仍然是单线程的。
// 也可以使用对象而不是数组。 每个属性将作为一个函数运行，结果将作为一个对象而不是一个数组传递给最终的回调。
async.parallel([
    function(callback) {
        setTimeout(function() {
            callback(null, 'one');
        }, 200);
    },
    function(callback) {
        setTimeout(function() {
            callback(null, 'two');
        }, 100);
    }
],
// optional callback
function(err, results) {
    `the results array will equal ['one','two'] even though the second function had a shorter timeout.`
});

// an example using an object instead of an array
async.parallel({
    one: function(callback) {
        setTimeout(function() {
            callback(null, 1);
        }, 200);
    },
    two: function(callback) {
        setTimeout(function() {
            callback(null, 2);
        }, 100);
    }
}, function(err, results) {
    // results is now equals to: {one: 1, two: 2}
});
  ```

### Common System Errors

- EACCES (Permission denied)
  - An attempt was made to access a file in a way forbidden by its file access permissions.
  - 访问被拒绝
- EADDRINUSE (Address already in use)
  - An attempt to bind a server (net, http, or https) to a local address failed due to another server on the local system already occupying that address.
  - 地址正在被使用（比如：端口号被占用）
- EEXIST (File exists)
  - An existing file was the target of an operation that required that the target not exist.
  - 文件已经存在
- EISDIR (Is a directory)
  - An operation expected a file, but the given pathname was a directory.
  - 给定的路径是目录
- ENOENT (No such file or directory)
  - Commonly raised by fs operations to indicate that a component of the specified pathname does not exist -- no entity (file or directory) could be found by the given path.
  - 文件 或 目录不存在
- ENOTDIR (Not a directory)
  - A component of the given pathname existed, but was not a directory as expected. Commonly raised by fs.readdir.
  - 给定的路径不是目录

### 学习资源

- [CNODE社区](https://cnodejs.org/) 
- [Node.js 简易教程](http://www.runoob.com/nodejs/nodejs-tutorial.html)
  - [Node入门](https://www.nodebeginner.org/index-zh-cn.html)
  - [Node.js包教不包会](https://github.com/ppker/node-lessons)
  - [CNODE-新手入门](http://cnodejs.org/getstart)
  - 其他参考链接
    - [Node.js 究竟是什么？](https://www.ibm.com/developerworks/cn/opensource/os-nodejs/index.html)
    - [Node.js是用来做什么的？](https://www.zhihu.com/question/33578075)
    - [什么是 node.js](http://www.infoq.com/cn/articles/what-is-nodejs)

Node.js 使用场景 & 实战

- [Node.js雪球实战半年谈](http://www.undozen.com/slides/xueqiu2012a/#21.1)
- [雪球上的 Node.js](http://mengxy.net/slides/nodejs-at-xueqiu/)
  - [国内有哪些网站使用了 Node.js](https://cnodejs.org/topic/50613e6601d0b8014822b6b9)
  - [Node.js & Uber](https://www.joyent.com/blog/node-js-office-hours-curtis-chambers-uber)
  - [Node.js 的优势和劣势](https://www.zhihu.com/question/19653241)
  - [node.js的15个应用场景](http://www.devstore.cn/essay/essayInfo/2199.html)
  - [How to decide when to use Node.js?](https://github.com/simongong/js-stackoverflow-highest-votes/blob/master/questions1-10/when-to-use-nodejs.md)
  - [优缺点及适用场景讨论](http://www.cnblogs.com/sysuys/p/3460614.html)
  - [Node.js 发展前景如何？适用于哪些场景？](https://www.zhihu.com/question/19587881)
  - [Node.js企业开发 一应用场景](http://n.thepana.com/2014/01/06/node-yingyong-changjing/)
  - [10个最佳Node.js企业应用案例：从Uber到LinkedIn](http://www.sohu.com/a/150175393_465223)
  - [极速Node.js：来自LinkedIn的10个性能提升秘籍](http://blog.jobbole.com/40135/)