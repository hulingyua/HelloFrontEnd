# Vue

### 1. 介绍

Vue.js (读音 /vjuː/，类似于 **view**) 是一套构建用户界面的**渐进式框架**。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，它不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[单文件组件](https://cn.vuejs.org/v2/guide/single-file-components.html)和 [Vue 生态系统支持的库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用程序提供驱动。

[查看官方API](https://cn.vuejs.org/v2/api/)

```javascript
`每个 Vue 应用都是通过 Vue 函数创建一个新的 Vue 实例开始的：`
var vm = new Vue({
  el : 'selector',
  data : {
    arr : ['H','e','l','l','o','V','u','e'],
    json : {name : 'King'},
    msg : 'Hello Vue'
  },
  methods : {
    show(){
      alert('Hello Vue');
    }
  }
});
```

### 2. 框架和库的区别

##### 2.1 框架

- 是一套完整的解决方案，**对项目的侵入性较大**，项目如果需要更换框架，则需要重新架构整个项目，如 Node 中的 Express。

##### 2.2 库（插件）

- 提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。

### 3. MVC、MVP、MVVM

##### 3.1 MVC

- M: Model 层 ( 负责数据存储 )
- V:  View 层 ( 负责数据展示 )   
- C:  Controller 层

##### 3.2 MVP

##### 3.3 MVVM ( Model–view–viewmodel )

##### 3.4 MVW、MV*

### 4. App的三大分类

##### 4.1 WebApp

##### 4.2 NativeApp

##### 4.3 HybirdApp

### 5. Vue 模板语法

> 在 Vue 实例中，任意数据发生改变，页面中的所有指令都会被 Vue 重新执行一次以进行求值操作。

#### 5.1 插值

##### ★ 文本

数据绑定最常见的形式就是使用“Mustache”语法 (双大括号) 的文本插值，双大括号会将数据<font color="red">解释为普通文本，而非 HTML 代码</font>：

```html
<span>Message: {{ msg }}</span>
```

#### 5.2 指令

> 指令 (Directives) 是带有 `v-` 前缀的特殊属性。指令的职责是，当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM。

##### ★ v-text

更新元素的 `textContent`。如果要更新部分的 `textContent` ，需要使用 `{{ Mustache }}` 插值。

```html
<span v-text="msg">这里的内容会被覆盖</span>
<!-- 和下面的一样 -->
<!-- 当网络环境较差的情况下会显示插值表达式或出现闪烁现象, 使用 v-cloak 或 v-text 解决 -->
<!-- 在vue.js加载完毕之前，由于元素有v-cloak指令存在，css样式生效，将元素隐藏起来，当vue.js加载完毕，会自动将所有元素上的v-cloak指令移除，那么css样式失效，元素就展示出来，这个时候插值表达式已经被解析完毕 -->
<style>
  [v-cloak]{
    display: none;
  }
</style>
<span v-cloak>{{msg}}</span>
```

##### ★ v-html

更新元素的 `innerHTML` 。**注意：内容按普通 HTML 插入 - 不会作为 Vue 模板进行编译**。如果试图使用 `v-html` 组合模板，可以重新考虑是否通过使用组件来替代。

在网站上动态渲染任意 HTML 是非常危险的，因为容易导致 [XSS 攻击](https://en.wikipedia.org/wiki/Cross-site_scripting)。只在可信内容上使用 `v-html`，**永不**用在用户提交的内容上。

```html
<div v-html="html"></div>
```

##### ★ v-show

根据表达式之真假值，切换元素的 `display` CSS 属性。

当和 `v-if` 一起使用时，`v-for` 的优先级比 `v-if` 更高。详见[列表渲染教程](https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if)

```html
<div v-show="true/false">{{ msg }}</div>
```

##### ★ v-if

根据表达式的值的真假条件渲染元素。但是并不是通过 CSS 样式来实现的，如果条件为 false，当前元素会**直接从 html 中移除**。如果在元素中还有其他指令，那么这些指令将不会被解析。

**注意**：如果切换显示特别频繁，则不推荐使用 v-if，因为每次在条件变为 true 的时候，v-if 所在的元素需要被重新创建，并且其中的指令，也要被重新解析，比较**耗性能**！

```html
<div v-if="isShow">{{ msg }}</div>
```

##### ★ v-else、v-else-if

**限制**：前一兄弟元素必须有 `v-if` 或 `v-else-if`。

##### ★ v-for

基于源数据多次渲染元素或模板块。此指令之值，必须使用特定语法 `alias in expression` ，为当前遍历的元素提供别名：

```html
<!-- 遍历数组 -->
<div v-for="value in arr">
  {{ value }}
</div>
<div v-for="(value,index) in arr" v-bind:key="index">
  <!-- index下标从零开始 -->
  {{ index }} ==> {{ value }}
</div>
<!-- 遍历1—10 -->
<li v-for="num in 10">
  {{ num }}
</li>
<!-- 遍历字符串 -->
<li v-for="str in 'Hello Vue'">
  {{ str }}
</li>
<!-- 遍历对象 -->
<div v-for="(value, key) in object"></div>
<div v-for="(value, key, index) in object"></div>
```

`v-for` 默认行为试着不改变整体，而是替换元素。迫使其重新排序的元素，你需要提供一个 `key` 的特殊属性：

```html
<div v-for="(item,index) in items" :key="index">
  {{ item.text }}
</div>
```

##### ★ v-on

绑定事件监听器。`v-on:事件类型="函数名称"` 或使用简写 `@事件类型="函数名称"`

在监听原生 DOM 事件时，方法以事件为唯一的参数。如果使用内联语句，语句可以访问一个 `$event` 属性：`v-on:click="handle('ok', $event)"`。

```html
<!-- 方法处理器 -->
<!-- 直接使用函数名称进行绑定事件，在事件处理函数被调用的时候，vue会默认传入事件对象 -->
<button v-on:click="doThis"></button>
<!-- 对象语法 (2.4.0+) -->
<button v-on="{ mousedown: doThis, mouseup: doThat }"></button>
<!-- 内联语句 -->
<!-- 使用函数调用模式 "函数名()" 绑定事件，在事件处理函数被调用的时候，默认不会传入事件对象，需要手动传入事件对象 $event -->
<button v-on:click="doThat('hello', $event)"></button>
<!-- 缩写 -->
<button @click="doThis"></button>
<!-- 停止冒泡 -->
<button @click.stop="doThis"></button>
<!-- 阻止默认行为 -->
<button @click.prevent="doThis"></button>
<!-- 阻止默认行为，没有表达式 -->
<form @submit.prevent></form>
<!--  串联修饰符 -->
<button @click.stop.prevent="doThis"></button>
<!-- 键修饰符，键别名 -->
<input @keyup.enter="onEnter">
<!-- 键修饰符，键代码 -->
<input @keyup.13="onEnter">
<!-- 点击回调只会触发一次 -->
<button v-on:click.once="doThis"></button>
<!-- 绑定事件的时候，不仅可以绑定函数名称，还可以绑定一些简单的表达式 -->
<button @click="num++">自加</button>
```

##### ★ v-bind

动态地绑定一个或多个特性，或一个组件 prop 到表达式。

在绑定 `class` 或 `style` 特性时，支持其它类型的值，如数组或对象。

在绑定 prop 时，prop 必须在子组件中声明。可以用修饰符指定不同的绑定类型。

没有参数时，可以绑定到一个包含键值对的对象。注意此时 `class` 和 `style` 绑定不支持数组和对象。

```html
<!-- 绑定一个属性 -->
<img v-bind:src="imageSrc">
<!-- 缩写 -->
<img :src="imageSrc">
<!-- 内联字符串拼接 -->
<img :src="'/path/to/images/' + fileName">
<!-- class 绑定 -->
<div :class="{ class: true/false }"></div>
<div :class="[classA, classB]"></div>
<div :class="[classA, { classB: isB, classC: isC }]">
<!-- style 绑定 -->
<div :style="{ fontSize: size + 'px' }"></div>
<div :style="[styleObjectA, styleObjectB]"></div>
<!-- 绑定一个有属性的对象 -->
<div v-bind="{ id: someProp, 'other-attr': otherProp }"></div>
<!-- 通过 prop 修饰符绑定 DOM 属性 -->
<div v-bind:text-content.prop="text"></div>
<!-- prop 绑定。“prop”必须在 my-component 中声明。-->
<my-component :prop="someThing"></my-component>
<!-- 通过 $props 将父组件的 props 一起传给子组件 -->
<child-component v-bind="$props"></child-component>
<!-- XLink -->
<svg><a :xlink:special="foo"></a></svg>
```

##### ★ v-model

在表单控件元素上创建<font color="red">双向数据绑定</font>。它会根据控件类型自动选取正确的方法来更新元素。`v-model` 会忽略所有表单元素的 `value`、`checked`、`selected` 特性的初始值。因为它会选择 Vue 实例数据来作为具体的值。

##### ★ v-pre

跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签。跳过大量没有指令的节点会加快编译。

```html
<span v-pre>{{ 我将不会被编译 }}</span>
```

##### ★ v-cloak

<font color="red">这个指令保持在元素上直到关联实例结束编译</font>。和 CSS 规则如 `[v-cloak] { display: none }` 一起用时，这个指令可以隐藏未编译的 Mustache 标签直到实例准备完毕。

```css
[v-cloak] {
  display: none;
}
```

```html
<div v-cloak>
  <!-- 这里的内容不会显示，直到编译结束 -->
  {{ message }}
</div>
```

##### ★ v-once

只渲染元素和组件**一次**。随后的重新渲染，元素/组件及其所有的子节点将被视为静态内容并跳过。这可以用于优化更新性能。

```html
<!-- 单个元素 -->
<span v-once>This will never change: {{msg}}</span>
<!-- 有子元素 -->
<div v-once>
  <h1>comment</h1>
  <p>{{msg}}</p>
</div>
<!-- 组件 -->
<my-component v-once :comment="msg"></my-component>
<!-- `v-for` 指令-->
<ul>
  <li v-for="i in list" v-once>{{i}}</li>
</ul>
```

#### 5.3 事件修饰符

使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用 `@click.prevent.self` 会阻止**所有的点击**，而 `@click.self.prevent` 只会阻止对元素自身的点击。

##### ★  .stop

阻止事件冒泡

##### ★  .prevent

阻止浏览器默认行为

##### ★  .capture

将事件设置为捕获阶段触发

##### ★  .self

只有元素自身能够触发该事件，事件冒泡等行为无法触发

##### ★  .once

事件只会被触发一次

```html
<!-- 阻止事件冒泡 -->
<a v-on:click.stop="doThis"></a>
<!-- 阻止浏览器默认行为 -->
<form v-on:submit.prevent="onSubmit"></form>
<!-- 修饰符可以串联 -->
<a v-on:click.stop.prevent="doThat"></a>
<!-- 只有修饰符 -->
<form v-on:submit.prevent></form>
<!-- 添加事件监听器时使用事件捕获模式 -->
<!-- 即内部元素触发的事件先在此处处理，然后才交由内部元素自身进行处理 -->
<div v-on:click.capture="doThis">...</div>
<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->
<!-- 即事件不是从内部元素触发的 -->
<div v-on:click.self="doThat">...</div>
<!-- 事件只会触发一次 -->
<a v-on:click.once="doThis"></a>
```

#### 5.4 特殊特性

##### ★ key

`key` 的特殊属性主要用在 Vue 的虚拟 DOM 算法，在新旧 nodes 对比时辨识 VNodes。如果不使用 key，Vue 会使用一种最大限度减少动态元素并且尽可能的尝试修复/再利用相同类型元素的算法。使用 key，它会基于 key 的变化重新排列元素顺序，并且会移除 key 不存在的元素。

当 Vue.js 用 `v-for` 正在更新已渲染过的元素列表时，它默认用“<font color="red">就地复用</font>”策略。如果数据项的顺序被改变，Vue 将不会移动 DOM 元素来匹配数据项的顺序， 而是简单复用此处每个元素，并且确保它在特定索引下显示已被渲染过的每个元素。

为了给 Vue 一个提示，以便它能跟踪每个节点的身份，从而重用和重新排序现有元素，你需要为每项提供一个唯一 `key` 属性。理想的 `key` 值是每项都有的且唯一的 id。

有相同父元素的子元素必须有**独特的 key**。重复的 key 会造成渲染错误。

建议尽可能在使用 `v-for` 时提供 `key`，除非遍历输出的 DOM 内容非常简单，或者是刻意依赖默认行为以获取性能上的提升。

最常见的用例是结合 `v-for`：

```html
<ul>
  <li v-for="item in items" :key="item.id"></li>
</ul>
```

### 6. 全局配置

##### ★ keyCodes

给 `v-on` 按键事件自定义键位别名。

```javascript
Vue.config.keyCodes = {
  v: 86,
  f1: 112,
  // 不可用驼峰命名: mediaPlayPause: 179
  // 取而代之的是 kebab-case 且用双引号括起来
  "media-play-pause": 179,
  up: [38, 87]
}
Vue.config.keyCodes['left-ctrl'] = 17;
```

参考书：大话设计模式

所有的字符串都包含空字符串

Mounted最早能够访问到DOM元素的地方

[Vue 双向数据绑定原理](https://segmentfault.com/a/1190000006599500)

[GUID (全局唯一标识符)](https://zh.wikipedia.org/zh-cn/%E5%85%A8%E5%B1%80%E5%94%AF%E4%B8%80%E6%A0%87%E8%AF%86%E7%AC%A6)

<div style="width:800px;text-align:center;">
Copyright© 2017 <a style="text-decoration: none;color: #FF0066;" href="https://github.com/kingmui" target="_blank">KINGMUI</a> All Rights Reserved<br />Updated on November 21, 2017
</div>